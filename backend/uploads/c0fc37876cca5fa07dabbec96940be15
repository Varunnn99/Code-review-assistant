from web3 import Web3
import json
import pandas as pd

# Connect to Ganache
w3 = Web3(Web3.HTTPProvider('http://127.0.0.1:8545'))
if not w3.is_connected():
    raise Exception("Failed to connect to Ganache")

# Load contract artifact
with open('build/contracts/EnergyAuction.json') as f:
    contract_json = json.load(f)
contract_abi = contract_json['abi']
contract_bytecode = contract_json['bytecode']

# Accounts from Ganache
accounts = w3.eth.accounts[:5]
owner = accounts[0]

# Deploy contract
EnergyAuction = w3.eth.contract(abi=contract_abi, bytecode=contract_bytecode)
tx_hash = EnergyAuction.constructor().transact({'from': owner, 'gas': 4000000})
tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
contract = w3.eth.contract(address=tx_receipt.contractAddress, abi=contract_abi)
print(f"Contract deployed at: {tx_receipt.contractAddress}")

# Using unlocked accounts; no manual signing needed

# Verify and register prosumers
for account in accounts:
    contract.functions.verifyProsumer(account).transact({'from': owner})
    contract.functions.registerHousehold().transact({'from': account})
    print(f"Verified and registered: {account}")

# Simulate bids and asks
bids = [
    {'account': accounts[1], 'energyAmount': Web3.to_wei(10, 'ether'), 'price': Web3.to_wei('0.03', 'ether')},
    {'account': accounts[2], 'energyAmount': Web3.to_wei(5, 'ether'), 'price': Web3.to_wei('0.04', 'ether')},
]
asks = [
    {'account': accounts[3], 'energyAmount': Web3.to_wei(12, 'ether'), 'price': Web3.to_wei('0.02', 'ether'), 'isRenewable': True},
    {'account': accounts[4], 'energyAmount': Web3.to_wei(8, 'ether'), 'price': Web3.to_wei('0.015', 'ether'), 'isRenewable': True},
]

# Off-chain auction logic
def run_auction(bids, asks):
    bid_df = pd.DataFrame(bids)
    ask_df = pd.DataFrame(asks)
    
    bid_df = bid_df.sort_values(by='price', ascending=False).reset_index(drop=True)
    ask_df = ask_df.sort_values(by='price').reset_index(drop=True)
    
    trades = []
    total_traded = 0
    bid_idx, ask_idx = 0, 0
    
    while bid_idx < len(bid_df) and ask_idx < len(ask_df):
        if bid_df.iloc[bid_idx]['price'] >= ask_df.iloc[ask_idx]['price']:
            clearing_price = (bid_df.iloc[bid_idx]['price'] + ask_df.iloc[ask_idx]['price']) // 2
            trade_amount = min(bid_df.iloc[bid_idx]['energyAmount'], ask_df.iloc[ask_idx]['energyAmount'])
            
            if trade_amount > 500 * 10**18 or not ask_df.iloc[ask_idx]['isRenewable']:
                break
            trade_value = (trade_amount * clearing_price) // 10**18
            fee = (trade_value * 10) // 100
            seller_payment = trade_value - fee
            
            trades.append({
                'buyer': bid_df.iloc[bid_idx]['account'],
                'seller': ask_df.iloc[ask_idx]['account'],
                'energyAmount': trade_amount,
                'clearingPrice': clearing_price,
                'fee': fee
            })
            
            bid_df.iloc[bid_idx, bid_df.columns.get_loc('energyAmount')] -= trade_amount
            ask_df.iloc[ask_idx, ask_df.columns.get_loc('energyAmount')] -= trade_amount
            total_traded += trade_amount
            
            if bid_df.iloc[bid_idx]['energyAmount'] == 0:
                bid_idx += 1
            if ask_df.iloc[ask_idx]['energyAmount'] == 0:
                ask_idx += 1
        else:
            break
    
    grid_trades = []
    for i in range(ask_idx, len(ask_df)):
        if ask_df.iloc[i]['energyAmount'] > 0:
            grid_trades.append({
                'seller': ask_df.iloc[i]['account'],
                'energyAmount': ask_df.iloc[i]['energyAmount'],
                'gridTariff': 5 * 10**15
            })
    
    return trades, grid_trades

# Run auction off-chain
trades, grid_trades = run_auction(bids, asks)
print("Trades:", trades)
print("Grid Trades:", grid_trades)

# Submit bids and asks
for bid in bids:
    deposit = (bid['energyAmount'] * bid['price']) // 10**18
    contract.functions.submitBid(bid['energyAmount'], bid['price']).transact({
        'from': bid['account'],
        'value': deposit
    })
    print(f"Submitted bid for {bid['account']}: {bid['energyAmount']} kWh at {bid['price']}")

for ask in asks:
    contract.functions.submitAsk(ask['energyAmount'], ask['price'], ask['isRenewable']).transact({
        'from': ask['account']
    })
    print(f"Submitted ask for {ask['account']}: {ask['energyAmount']} kWh at {ask['price']}")

# Clear auction on-chain
receipt = w3.eth.wait_for_transaction_receipt(
    contract.functions.clearAuction().transact({'from': owner})
)
print("Transaction Receipt:", receipt)

# Check results
trade_count = contract.functions.getTradesCount().call()
print("Trade Count:", trade_count)
for i in range(trade_count):
    trade = contract.functions.getTrade(i).call()
    print(f"Trade {i}:", trade)
fees = contract.functions.getTotalFeesCollected().call()
print("Total Fees:", fees)

# ---- Pretty Results Table ----
trade_records = []
for i in range(trade_count):
    buyer, seller, energyAmount, price, timestamp = contract.functions.getTrade(i).call()
    trade_records.append({
        "Trade #": i,
        "Buyer": buyer,
        "Seller": seller,
        "Energy (kWh)": int(energyAmount) // 10**18,
        "Price (ETH)": Web3.from_wei(price, "ether"),
        "Timestamp": pd.to_datetime(timestamp, unit="s")
    })

df_trades = pd.DataFrame(trade_records)

# Grid trades (from off-chain matching)
grid_records = []
for i, g in enumerate(grid_trades):
    grid_records.append({
        "Grid Trade #": i,
        "Seller": g["seller"],
        "Energy (kWh)": int(g["energyAmount"]) // 10**18,
        "Tariff (ETH)": Web3.from_wei(g["gridTariff"], "ether")
    })

df_grid = pd.DataFrame(grid_records)

print("\n=== On-Chain Trades ===")
print(df_trades if not df_trades.empty else "No trades executed")

print("\n=== Residual Grid Trades (Off-chain) ===")
print(df_grid if not df_grid.empty else "No grid trades executed")
